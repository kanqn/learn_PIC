## PICアセンブラ

### 値の書き込みについて

#### MOVLW B'00001111'  
文字列をWレジスタ(ALUのアキュムレータのようなレジスタ)に書き込む命令  
  
#### MOVWF PORTB
Wレジスタの内容をPORTBに書き込む  

なお、MOVLFのような文字列を直接渡すことはPICの命令長が14ビットに対して、  
リテラル→ファイルレジスタは14ビットを超えてしまうためできない  
  
### MCLRピン

電圧低下やプログラムミスでPICが不安定になる時があって誤動作解除に使う
MCLRピンがLレベルになるとPICマイコンがリセットされる
(MCLRリセット)

### 入出力設定

#### TRIS-A TRIS-B  
  
PICの入出力設定はTRIS-AとTRIS-Bという特殊機能レジスタで行う  
  
TRIS-A(5ビット幅のレジスタ)がAポートの入出力設定を行い、  
(RA0,RA1,RA2,RA3,RA4)  
  
TRIS-B(8ビット幅のレジスタ)がBポートの入出力設定を行う  
(RB0,RB1,RB2,RB3,RB4,RB5,RB6,RB7)  
  
なお、ビットが0なら出力,1なら入力となる  

#### CLRF TRISA

CLRF: レジスタの全ビットを0にする  
例: CLRF TRISA  (Aポートを全て出力に設定する)  
なお、逆となる**全ビット1にするというのはない**ため、  
全ビット1にしたい場合は、 MOVLW , MOVWFを使用する  

### バンクと切り替えについて
PICは電源投入時は、デフォルトだとBANK0にアクセスするため、  
BANK1にアクセスするためには(TRIS-AやTRIS-BはBANK1にある)バンク切り替えが必要  
切り替えにはSTATUSというレジスタを使用する  
  
#### STATUSレジスタ  

BANK0と1両方にある8ビットのレジスタで、バンク切り替えに使うビットはRP0(5ビット目)とRP1(6ビット目)  
ただし、PIC16F84AはRP0だけを使用する  
もちろんRP0ビットが0なら、BANK0になって、1ならBANK1となる。  

#### 実際のBANK切り替え  
  
BSF: ビットを**1**にしたい場合に使用  
例: BSF STATUS, RP0 (STATUSレジスタのRP0のビットを1にする、つまりはBANK1に切り替える)  
  
BCF: ビットを**0**にしたい場合に使用  
例: BCF STATUS, RP0 (STATUSレジスタのRP0のビットを0にする、つまりはBANK0に切り替える)  

なお、BANK1に切り替えた場合は、操作が終わった後は**必ずBANK0に戻すこと**  
  

#### MOVF f,d
ファイルレジスタの内容を格納先ｄに書き込む  
  
入力設定してるPORT-AをPORT-Bに出力する例  
例: MOVF PORTA, W (PORT-Aの内容 → Wレジスタに書き込む)  

#### 未使用ピンは出力にすること  

### 条件分岐

#### BTFSC , BTFSS
  
BTFSC f,b: fレジスタのbビット目がビットが0なら次の行をスキップする  
BTFSS f,b: fレジスタのbビット目がビットが1なら次の行をスキップする  
なお、次の行をスキップするため、2行目に新しく条件分岐を記述することで細かい分岐にできる  
(なお、2行目にIFを入れないでGOTOで関数ジャンプ→ジャンプ先でIF処理もいける)  

#### DECFSZ f , d  

f - 1 → d  
→dの値が0だったら次の行をスキップする  
例: DECFSZ T1,F

### 初期設定  

#### ORG n

ORGは疑似命令で、プログラムを開始するアドレスを指定する  
ORG命令の次の行がORGで指定した番地nに書き込まれる  
例: 処理Aが00h番地に書かれる  
ORG 00h  
処理A  
  
#### 00hについて  

電源投入時やリセットされた時に、プログラムは00hから開始される  
そのため、割り込み処理が04hにある場合は、00hにgoto命令でジャンプさせて、  
その先でメインルーチンを書くようにすること  
※割り込み処理を使わない場合は、gotoで飛ばす必要はない  
割込みが発生すると、PICはプログラムメモリの**04h番地に強制的にジャンプする**  

#### EQU
レジスタに任意のラベル名をつけることができる疑似命令  
以下は、0Ch番地にT1というラベル名をつける例  
例: T1 EQU 0Ch  

### 遅延タイマー  

PICでは、**クロック4回で1つの命令**が実行され、これを**1サイクル**という  
使用するセラロックが10MHzだった場合の1サイクルにかかる時間:  
1/10,000,000 x 4 = 0.0000004s == 1サイクル : 0.4μs  

1サイクルにかかる時間がわかるとタイマーを作ることができる  
以下は0.5秒のタイマーの計算例  

0.5s = 500ms = 500,000μsのタイマー  
500,000 / 0.4 = 1,250,000サイクル == 0.5sタイマ : 125万サイクル  
ただし、さすがに125万サイクル記述するのは容量的(8bit(256)しかないため)に現実的ではないため反復処理を作る  
1: 0.4msecの処理を250回行う処理(100msec分)を書く  
2: 100msecを5回繰り返す処理を書く  
これで、0.5sとなる  

また、以下のプログラムがある場合は、サイクル数はこうなる  

```

TIM 04              ;ラベルはサイクル0
      MOVLW D'250'  ;1サイクル
      MOVWF T1      ;1サイクル
TIMLOOP1            ;ラベルはサイクル0
      NOP           ;1サイクル
      DECFSZ T1, F  ;1サイクル
      GOTO TIMLOOP1 ;GOTOは2サイクル
      RETURN        ;RETURNは2サイクル

```

**1 + 1 + (1 + 1 + 2) x 250 + 1(スキップするDECFSZ) - 2(スキップされたGOTO) + 2 = 1003サイクル**  
これを5回行えば、5015サイクルとなり、0.5msecタイマーとなる  

### 割り込み処理(外部割込み)

#### 割り込みルーチン  
![割込みルーチン](https://github.com/kanqn/learn_PIC/assets/86160454/3e98be47-6be0-4264-bd8d-ecfebaf3f4d9)

#### 具体的な割り込み手順  

割込みが発生すると、PICはプログラムメモリの**04h番地に強制的にジャンプする**  

INTCONレジスタ: 割り込み条件の設定と割り込みが発生したかどうかチェックする  
例: RB0/INT外部割込みを使う  
→GIEビットとINTEビットに1をセットする(割り込みが発生するとINTFビットが1になる)  
![intconx](https://github.com/kanqn/learn_PIC/assets/86160454/02b6ab98-ca7e-4152-b5cb-85fdaa5cde4b)  

  
OPTION_REGレジスタ: 外部割込み等の各種設定をする  
外部割込みで使うのはINTEDGビットで、0で立ち下がりで割り込み、1で立ち上がりで割り込む    
  
  
#### 割込み処理に入る前に、必要なレジスタを汎用レジスタに退避しておく。  

汎用レジスタに退避しておくべきレジスタは大抵の場合は、WレジスタとSTATUSレジスタで、  
復帰させれば元の処理を正常に継続できる  
**また、STATUSレジスタはBCF , BSF , SWAPF , MOVWFだけを使ってアクセスすることが推奨されている。**  
以下はSTATUSレジスタ退避,復帰のサンプル  

```
STATUS_BU EQU 0Ch ;バックアップ用変数宣言
        MOVF STATUS,W ;ここから退避処理
        MOVWF STATUS_BU

        ;割り込み処理の記述

        MOVF STATUS_BU,W ;ここから復帰処理
        MOVWF STATUS

```

また、MOVFだと退避前と復帰後でSTATUSレジスタの値が異なってしまうため、**SWAPF命令を使用する**  

#### SWAPF命令

SWAPF STATUS , W
上位4ビットと下位4ビットを入れ替えて格納する  
上下のビットが入れ替わるが、復帰時に元に戻るため、復帰後のSTATUSレジスタは退避前と同じ値になる  

以下がSWAPFを使用したレジスタ退避,復帰のサンプル(MOVFをSWAPFに変えただけ)  

```
STATUS_BU EQU 0Ch
        SWAPF STATUS,W
        MOVWF STATUS_BU

        ;割り込み処理を記述

        SWAPF STATUS_BU,W
        MOVWF STATUS
```

#### INTCONレジスタのフラグを0に戻す  
  
今回はRB0/INTの入力変化時の割込み設定のため、INTEビットを0に戻しておく  


#### 割り込み処理の実行  
  
レジスタ退避→フラグを0にするところまでやってようやく割り込み処理を記述できる  

#### レジスタの復帰  

必要なレジスタを復帰させる  

#### INTCONレジスタのGIEビットを1に戻す  

GIEビットを1に戻すことで、全体の割込みを許可する  
**RETFIE**: GIEビットを1にして、元のルーチンへ戻る。  
